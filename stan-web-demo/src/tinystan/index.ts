interface WasmModule {
  _malloc(_0: number): number;
  _free(_0: number): void;
  _tinystan_create_model(_0: number, _1: number, _2: number): number;
  _tinystan_destroy_model(_0: number): void;
  _tinystan_model_param_names(_0: number): number;
  _tinystan_model_num_free_params(_0: number): number;
  _tinystan_separator_char(): number;
  _tinystan_sample(_0: number, _1: number, _2: number, _3: number, _4: number, _5: number, _6: number, _7: number, _8: number, _9: number, _10: number, _11: number, _12: number, _13: number, _14: number, _15: number, _16: number, _17: number, _18: number, _19: number, _20: number, _21: number, _22: number, _23: number, _24: number, _25: number, _26: number, _27: number): number;
  _tinystan_get_error_message(_0: number): number;
  _tinystan_get_error_type(_0: number): number;
  _tinystan_destroy_error(_0: number): void;
  _tinystan_api_version(_0: number, _1: number, _2: number): void;
  _tinystan_stan_version(_0: number, _1: number, _2: number): void;
  // above generated by --emit-tsd to emscripten
  lengthBytesUTF8(str: string): number;
  UTF8ToString(ptr: number, max?: number): string;
  stringToUTF8(str: string, outPtr: number, maxBytesToWrite: number): number;
  getValue(ptr: number, type: string): number;
  HEAPF64: Float64Array;
  stdoutText: string;
}


const NULLPTR = 0;

class StanModel {
  private m: WasmModule;
  private callback: ((s: string) => void) | null = null;

  private constructor(m: WasmModule, callback: ((s: string) => void) | null = null) {
    this.m = m;
    this.callback = callback;
  }

  public static async load(createModule: ((proto?: object) => Promise<WasmModule>), printCallback: ((s: string) => void) | null): Promise<StanModel> {

    const Module: { [k: string]: any } = { stdoutText: "" };
    if (printCallback !== null) {
      Module.print = (function (): (args: any[]) => void {
        return (...args: any[]) => {
          const text = args.join(' ');
          Module.stdoutText = Module.stdoutText + text + '\n';
        }
      })();
    }
    const module = await createModule(Module);
    return new StanModel(module, printCallback);
  }

  // currently assumes a 1-d model and hard codes many arguments.
  // Could easily be extended to support full functionality a.la TinyStan's Python API
  public sample(data: string, num_chains: number = 4, num_samples: number = 1000): number[] {

    const seed = Math.floor(Math.random() * 1000000);

    // Create the model
    const err_ptr = this.m._malloc(4);

    const data_ptr = this.m._malloc(this.m.lengthBytesUTF8(data) + 1)
    this.m.stringToUTF8(data, data_ptr, this.m.lengthBytesUTF8(data) + 1);
    const model = this.m._tinystan_create_model(data_ptr, seed, err_ptr);
    this.m._free(data_ptr);

    if (model == 0) {
      // Get the error code
      const err_code = this.m.getValue(err_ptr, '*');

      // Get the error message
      const err_msg_ptr = this.m._tinystan_get_error_message(err_code);
      const err_msg = this.m.UTF8ToString(err_msg_ptr);

      console.error("Error creating model: ", err_msg);

      this.m._tinystan_destroy_error(err_code);
      throw new Error();
    }

    // Get the parameter names
    const paramNames = this.m.UTF8ToString(this.m._tinystan_model_param_names(model));
    // Get the number of free parameters
    const n_params = paramNames.split(",").length;

    // Allocate memory for the output
    const n_out = 1000 * 4 * (n_params + 7);
    const out_ptr = this.m._malloc(n_out * 8);

    // Sample from the model
    this.m.stdoutText = "";
    const result = this.m._tinystan_sample(model, num_chains, NULLPTR, seed, 1, 2.0, num_samples, num_samples, 2 /* diagonal */, NULLPTR,
      1, 0.8, 0.5, 0.75, 10, 75, 50, 25, 0, 1.0, 0.0, 10, 100,
      num_chains, out_ptr, n_out, NULLPTR, err_ptr);

    if (this.callback !== null) {
      this.callback(this.m.stdoutText);
    }

    // Check for errors
    if (result != 0) {
      // Get the error code
      const err_code = this.m.getValue(err_ptr, '*');

      // Get the error message
      const err_msg_ptr = this.m._tinystan_get_error_message(err_code);
      const err_msg = this.m.UTF8ToString(err_msg_ptr);

      console.error("Error sampling: ", err_msg);

      // Don't forget to free the error message and the error pointer
      this.m._tinystan_destroy_error(err_code);
      throw new Error();
    }
    this.m._free(err_ptr);

    // Calculate the average of theta

    const out_buffer = this.m.HEAPF64.subarray(out_ptr / Float64Array.BYTES_PER_ELEMENT, out_ptr / Float64Array.BYTES_PER_ELEMENT + n_out);
    const x = [];
    for (let i = 0; i < num_chains * num_samples; i++) {
      const elm = out_buffer[i * (n_params + 7) + 7];
      x[i] = elm;
    }


    // Clean up
    this.m._tinystan_destroy_model(model);
    this.m._free(out_ptr);

    return x;

  }

  public version(): string {
    const major = this.m._malloc(4);
    const minor = this.m._malloc(4);
    const patch = this.m._malloc(4);
    this.m._tinystan_stan_version(major, minor, patch);
    const version = this.m.getValue(major, 'i32') + "." + this.m.getValue(minor, 'i32') + "." + this.m.getValue(patch, 'i32');
    this.m._free(major);
    this.m._free(minor);
    this.m._free(patch);
    return version;
  }

}


export default StanModel;
